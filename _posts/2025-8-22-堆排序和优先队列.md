---
layout: post
title: "堆排序和优先队列"
date: 2025-8-22
tags: [编程]
comments: true
author: Minrain
---
### 堆的定义及基本性质
(二叉)堆是一个数组，也可以看做近似的完全二叉树，d叉堆则可以看做近似完全d叉树，若一层未满，要求元素严格从左向右排列，不允许有空。

如此，我们很容易得到其基本性质：parent(i): $\lfloor \frac{i}{2} \rfloor$ child_l/r(i): $2i,2i+1$ 

堆又分为最大堆和最小堆。最大堆满足每个节点的父节点值大于该节点(除根节点)，最小堆反过来，满足每个节点的父节点值小于该节点。  

我们可以类似树定义堆的高度，堆的高度是根节点到叶节点最长简单路径的长度，而一个堆中节点的高度指该节点到叶节点最长简单路径的长度。需要指出的是，比如一个非完全的二叉树，{1,2,3,4}，节点4高度为0，节点2高度为1，节点3高度为0。请多对照定义使用高度概念。

### 对堆进行维护
首先，我们先讨论当节点i的两个子节点对应的树已经是最大堆时，如何把节点i对应的树最大堆化：

```
Max_heapify(A,i):
l = left(i)
r = right(i)
if l ≤ heapsize and A[i] < A[l]:
    largest = l
else:
    largest = i
if r ≤ heapsize and A[largest] < A[r]:
    largest = r
if largest ≠ i:
    exchange A[largest],A[i]
    Max_heapify(A,largest)
```

直觉上很容易理解，比较该节点和两个子节点的大小，把最大的节点换到父节点的位置；由于子节点对应子树都是符合条件的最大堆，交换后只有原本的父节点值对应的子树不是最大堆，递归执行，使其符合最大堆的规则。

通过这个方法，我们得到了当两个子节点对应子树满足最大堆条件时，如何将i作为根节点的子树最大堆化。

乍一看这个算法的提出有些突兀，实际上它是为接下来要讨论的，如何建造最大堆服务的。

如何建造最大堆：
```
Build_max_heap(A):
A.heapsize = A.length
for i = $\lfloor \frac{n}{2} \rfloor$ to 1:
    Max_heapify(A,i)
```

这里有两点需要注意：
1. 为什么for循环这么写：

声明 $\lfloor \frac{n}{2} \rfloor$ +1到 $n$ 是所有叶节点。证明是容易的，一个节点i如果有孩子(非叶结点)，那么2i(孩子节点) < n。于是得到最大的非叶节点对应序号是小于等于n/2的第一个数，也即n/2向下取整。

2. 为什么这样可以构建最大堆：

考虑循环不变式：序号i迭代结束后，i到 $\lfloor \frac{n}{2} \rfloor$ 的节点作为根节点对应的子树均符合最大堆要求。

初始化：i = $\lfloor \frac{n}{2} \rfloor$ 时，两个孩子节点均为叶节点，迭代结束符合要求。

保持：考虑序号k节点，左右节点分别为2k,2k+1，要么落在叶节点中，要么落在[k+1,$\lfloor \frac{n}{2} \rfloor$]中，均符合要求；迭代之后，序号k节点符合要求。 

结束：1节点迭代后，1节点符合最大堆要求，证明完毕。

接下来我们分析该算法的时间复杂度。

首先，元素数目为n的堆，高度为 $h = \lfloor \lg n \rfloor$。

证明是容易的：考虑完全二叉树，高度为h，则 $n = 2^0 + 2^1 +...+ 2^h = 2^{h+1} - 1$,于是对于完全二叉树，该公式适用；再考虑普通二叉堆，将其看做一个完全二叉树增加一部分节点的组合。设堆高h,则 $h=完全二叉树高h' + 1,n = 2^{h'} - 1 + k$，其中k表示增加节点的个数，且 $1≤ k ≤ 2^{h'}$。从而一般二叉堆服从公式，证明完毕。 

其次，高度为h的节点，最多有 $\lceil \frac{n}{2^{h+1}} \rceil$ 个。

证明如下：考虑高度为h的完全二叉堆，考虑高为y的节点，其对应深度为 d = h - y,数量为 $2^d$。此时 $n = 2^{h+1} -1 $，结论成立；再考虑普通二叉堆，可看做高为y的完全二叉堆，加上部分叶节点的组合。满足 $n = 2^{y+1} - 1 +k$,k为增加节点的个数。考虑高为h的节点，在原本的完全二叉堆中有 $\lceil \frac{n-k}{2^{h+1}} \rceil$ 个，每个原本高度为h的点，控制新增的 $ 2^{h+1}$ 个点；增加k个新点，增加 $\lceil \frac{k}{2^{h+1}} - \frac{1}{2} \rceil$ 个高位h的点；两者相加，即得结果(如果实在不明白为什么增加k个点会增加这么多新高为h的点，列表格看一眼就懂了)。 证明完毕。

最后，高度为h的节点，进行Max_heapify，时间复杂度为O(h)。

这个证明是容易的，高度为h，最多进行h次交换操作，每次交换操作花费常量时间，证毕。

有了这些断言，我们开始计算时间复杂度：

$$ \sum_{h=1}^{\lfloor \lg n \rfloor} \lceil \frac{n}{2^{h+1}} \rceil O(h) = O(n \sum_{h=1}^{\lfloor \lg n \rfloor} \frac{1}{2^{h+1}}  h) $$

求和式是一个等差等比数列求和，记作Sn,可以通过高中知识同乘公比，相减等等操作求出准确结果，也可以直接使用微积分完成估计。得到最终结果小于某个常数(考虑 $xe^{-x}$ 在1到无穷上的积分)，因此最后得到时间复杂度: O(n)。

### 堆排序算法
本章的主题是排序，接下来我们进入主题，堆排序。

```
Heap_sort(A):
Build_max_heap(A)
for i = A.heapsize to 2:
    exchange A[1],A[i]
    Max_heapify(A,1)
    A.heapsize - 1
```

原理很清晰。最大堆满足A[1]是最大元素，于是只需要不断进行最大堆化，不断把A[1]按顺序从后向前填充，就得到有序序列。升序降序区别在于，一个用最大堆，另一个用最小堆。最小堆的一切几乎和最大堆相同，不再赘述。

时间复杂度分析也是容易的。Build_max_heap,复杂度O(n);n个元素，每次调用Max_heapify花费O(lgn)，复杂度O(nlgn)。总的复杂度为O(n+nlgn) = O(nlgn)。

注意一点，若所有元素不同，其时间复杂度为Ω(nlgn)。

证明如下：我们考虑一棵完全二叉树，在对完全二叉树完成证明后，一般情况可归化到特殊情况，完成证明。

假设该完全二叉树高度为h,则总元素数量 $n = 2^{h+1} - 1$,最后一层元素数量为 $2^{h}$。

我们考虑前 $2^{h}$ 个被取出来的元素。这是因为该数正好取完最后一层，整个树将变成高度减少1的另一棵完全二叉树。我们先对这种情况进行探究，看是否能够找到思路。如果可以，可以尝试递归，也许可以解决问题。

接着通过观察，我们发现，这些元素在原来的二叉树中，必然构成一个子树。因为若某个子节点被取出，其父节点必然也被取出。我们找到这些节点在堆中的分布，统计距根节点的距离，也许就能得到结果。

关键的是能够进行放缩从而计算下界的元素。我们观察到，如果能够确定取出来的元素中不属于最后一层的元素数目的下界，那么进行放缩，把他们从第一层按顺序放下去，就能够得到一个花费时间的下界。

确定不属于最后一层的元素数目的下界，也可以说是确定最后一层中被取出来的元素数目的上界。这个上界是 $2^{h-1}$，证明如下：

反证法。假设最后一层被取出的元素数目 > $2^{h-1}$ ,那么倒数第二层至少被取出
$2^{h-2}$ 个(大于)，倒数第三层，倒数第四层...最终对这些被取出的元素数目求和，取出的元素必然> $2^{h}$ 个,矛盾。

那么不属于最后一层的元素最少有 $2^{h-1}$ 个。把它们从第一层往下排，能排h-1层。第h-1层的元素，一共 $2^{h-2}$ 个，移动到根节点，要移动h-2次。最终，我们直接得到一个下界：$(h-2)*2^{h-2}$

把h换成n,h=lg(n+1) -1,即得所证。

关于这个问题，我思考了2个小时，有一些相近的思路，但最终没有完成证明。这个证明来自stackoverflow，可以在github上最高星的CLRS Solutions中找到。我的教训是：面对难题，即便想不出来，也不要看答案。有时间就想一想，有时间就想一想。如果查看答案，第一会有一种挫败感，因为不是自己想出来的答案；第二，思维得不到提高，也许难以进步。
### 优先队列
优先队列是用来维护由一组元素构成的集合S的数据结构，其中每个元素都有一个值，称为关键字。

优先队列分为最大优先队列和最小优先队列，最大优先队列的应用是任务重要度排序，最小优先队列的应用是作为时间驱动事件的模拟器。本文只介绍最大优先队列，最小优先队列实现类似。

对于最大优先队列，我们要实现以下几个功能：
1. 取最大值,Max
2. 返回最大值并删去最大值，Extract_max
3. 插入一个元素，Insert
4. 增加一个元素的关键字，Increase

我们可以使用堆实现优先队列(默认A是最大堆)。
比如：
```
Max(A):
return A[1]

Extract_max(A):
if A.heapsize>0:
    max = A[1]
    exchange A[1],A[A.heapsize]
    A.heapsize -= 1
    Max_heapify(A,1)
    return max
else
    print("nothing exist")
    return 

Increase(A,i,key):
if A[i] > key:
    print('key is greater than i!')
else:
    A[i] = key
    while(i > 1):
        if A[parent(i)] < A[i]:
            exchange A[parent(i)],A[i]
        i = parent(i)

Insert(A,key):
A.heapsize += 1
A[A.heapsize] = -∞ 
Increase(A,A.heapsize,key)
```
原理通俗易懂，不再赘述。
