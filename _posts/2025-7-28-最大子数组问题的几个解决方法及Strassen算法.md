---
layout: post
title: "最大子数组问题的几个解决方法及Strassen算法"
date: 2025-7-28
tags: [编程]
comments: true
author: Minrain
---
按理说应该在昨晚写完这篇博文，不过最近沉迷碧蓝之海，耽误了学习时间，今早补全。

最大子数组问题即指：给定一个n元数组，找出其中一个连续的子数组，使该子数组各元素和最大。

最容易想到的是暴力方法，我们只需要对每个元素，找到以它为首项元素的子数组中的最大子数组，遍历结束即可得到答案。这个解决方法的时间复杂度为O($n^2$)。

接下来照猫画虎，我们发现运用不久前学习的分治思想，也可以解决这个问题。具体来说，首先将n元数组分为左右两个n/2元数组，问题分解为；找到两个n/2元数组的最大子数组和跨越两个数组的最大子数组。只要解决跨越数组的最大子数组问题，也就通过递归方法解决了问题。

关于跨越数组的最大子数组问题，是容易解决的。我们只需要选中跨越两数组的两个数字，左边向左遍历找到左侧的最大子数组，右边向右遍历找到右侧的最大子数组，合并即得到最终结果。

这个算法的时间复杂度为O(nlogn)，得到了优化。

然而，并非所有分治算法都得到的是最优结果，我们可以不通过分治，而利用问题本身的特性，得到一个复杂度为O(n)的算法。

算法思想如下：从左向右遍历数组，使用current_sum储存目前的求和，使用max_sum记录遍历过程中的最大值。如果current_sum＜0，则以下一个≥0的元素为首项元素，开启新一轮current_sum求和。

时间复杂度为n是毋庸置疑的，可能该算法不好理解，下面给出我个人的理解。想象一个折线图，初始是0，第i次增加数组中第i个元素的值，那么最大子数组连续和对应到图表上即为最高点的值。

考虑第k个元素，则在k之前的元素，在符合规则的情况下能给k提供的最大和，是加到折线图最低点对应的元素的位置。注意，折线图从0开始，一条线对应一个加减的数值，n个值会有n+1个点。反向从0开始，走一条线说明加减一个值，你会发现两个图像关于y=a(对于具体情况，a可以具体表示)对称。由对称性，原本图像的最低点变为最高点。所以，沿着线走到原本图像最低点的位置，对应的y值即是前k-1个元素所能提供的最大和。

当最低点＜0，我们能做的最优选择就是舍弃前面的元素，更换一个＞0的元素作为排头重新开始连续求和。否则，若最大子数组包含k即其之后的元素，其必包含前k-1个元素。

由于在过程中max_sum记录了所有可能的最大子数组中的最大结果，因此遍历完成后max_sum即为所求结果。至此，我们验证了算法的正确性。

接下来讲了矩阵乘法的Strassen算法。按照朴素的思想，矩阵相乘的时间复杂度为O($n^3$)，这也是矩阵相乘定义得到的结果，简单的递归，即矩阵分块运算不能优化该结果。而Strassen算法通过代数变形，由Ai,Bi(矩阵A,B的子矩阵)的加减构造出10个Si，再通过Ai,Bi,Si的两两搭配的乘法构造出7个Pi,最后通过Pi线性组合表示出Ci,得到最终结果。相当于以增加常数次矩阵加法为代价，减少了一次矩阵乘法。该算法时间复杂度来到O($n^lg7$)。

这个结果是通过递推式T(n) = 7T(n/2)+θ($n^2$)得到(不考虑n=1)，递推式的求解将由后续的主定理给出。

