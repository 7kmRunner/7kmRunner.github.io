---
layout: post
title: "归并排序"
date: 2025-7-26
tags: [编程]
comments: true
author: Minrain
---
本篇主要介绍归并排序与部分算法分析。

对于一个规模为n的复杂问题，可以通过分治的思想进行解决。

一般有三个步骤：分解，解决，合并。

分解步骤将问题变为规模更小的子类问题。当规模足够小时，问题可能就便于解决，比如，当一个数组里只有一个元素，要求对其排序，那么它本身就是有序的。

解决步骤顾名思义，就是解决简单的子问题。

最后是合并，将子问题的结果合并为最终答案，占据一定的运算时间。

算法分析中，一个通过分治法解决的问题，其运行时间需要分别考虑三个步骤的时间，将其相加。

归并排序通过递归的调用自身，将n个数排序问题转化为2组n/2个数排序问题再进行合
并。当n为1时，完成1个数的排序任务，自下向上进行合并，最终得到排序结果。

以下给出归并排序的伪代码:
``` 
MERGE_sort(A,p,r):
    if r - p > 0
    MERGE_sort(A,p,(p+r)/2)        
    MERGE_sort(A,(p+r)/2+1,r)
    MERGE(A,p,q,r) r = (p+q)/2
MERGE(A,p,q,r):
    n1 = q - p + 1
    n2 = r - q
    for i = 1 to n1
        B[i] = A[p + i -1]
    for j = 1 tp n2
        C[j] = B[q + j]
    i,j = 1
    for k = p to r
        if i <= n1 and (j > n2 or B[i] < C[j])
            A[k] = B[i]
            i = i + 1
        else
            A[k] = C[j]
            j = j + 1
```
这是一个算法复杂度为nlogn的算法，与之相对，冒泡排序和插入排序的复杂度为n方。

在习题中提到由于常系数的影响，在数据规模较小时插入排序可能比归并排序更快，
因此可以选择当数据规模较小时选用插入排序解决问题，之后再进行合并，完成优化。

本节中还提到了二分搜索，霍纳规则等等内容。

接下来进入第三节，函数的增长性。大多数是某些数学基础知识的普及，按下不表。

值得注意的是，这里除了O，Ω之外，还出现了o,ω的定义，分别类似于＜，＞；以及给出了多重函数的定义：$$f^*(x) = min\{i: f^i(x) ≤ c,c为常数\}$$

习题中有一些耐人寻味的小细节，有助于增加对增长速度的直观感受和理解。提到了$Ω^∞$，$\~{O}$(读作O软)等概念，O软是忽略log贡献的比较方法。

我打算锻炼一下身体，接着看见证逆潮；读一个小时后，继续算法导论。