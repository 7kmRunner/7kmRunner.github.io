---
layout: post
title: "解决递归式的几种方法，主定理"
date: 2025-7-29
tags: [编程]
comments: true
author: Minrain
---
本文主要内容:解决递归式的三种常见方法——代入法、递归树法、主定理法，及对于主定理方法的详细介绍和证明。本篇文章所指的解，是指满足T(n) = θ(g(n))的g(n)。

#### 代入法
主要思路来自直觉与经验。具体来说，给定一个递归式，凭借自己的经验给出一个上界/下界，并通过归纳法等方法进行严格验证。通过上下界的夹逼，缩窄范围，直至得到较好的解。

需要注意的点有：
1. 递推过程得到的结果一定严格与假设相符，不能随意舍弃。
2. 有时通过减去一个低阶项，反而更容易完成证明。

#### 递归树法
很好理解的一种方法，类似归纳法。通过画出一颗包含根节点和叶节点的递归树，详细计算根节点部分每一层分解合并问题产生的开销，以及叶节点部分总共解决问题产生的开销，相加得到最终结果。

这种方法通过观察归纳，可以很好地为代入法提供尝试的思路，找到较为精确的上下界，同时，也是完成主定理证明中重要的一环。

#### 主定理
本章重点，内容如下：

给定递推式
$$ T(n) = \begin{cases}
   \Theta(1) & \text{if } n = 1 \\
   aT(n/b) + f(n) & \text{if } n >1
   \end{cases} 
$$
其中a≥1,b>1，f(n)为n的非负函数，
那么有：
1. 若对某个常数 $\epsilon > 0$ 有 $f(n) = O(n^{log_b a - \epsilon})$，则递归式的解为 $T(n) = \Theta(n^{log_b a}) $。
2. 若f(n)满足 $f(n) = \Theta(n^{log_b a})$,则递归式的解为 $T(n) = \Theta(n^{log_b a}lgn)$。
3. 若对某个常数 $\epsilon > 0$ 有 $f(n) = \Omega(n^{log_b a} + \epsilon)$,且满足正则化条件，对某个常数 c<1 有 aT(n/b) ≤ cT(n),那么递归式的解满足 $T(n) = \Theta (f(n))$。

从直觉上看，这个定理阐述如下事实：比较 $f(n)$ 和 $n^{log_b a}$ 多项式意义下的大小，取两者中较大的一个作为最终结果。如果两者相等，最终结果乘上一个lgn。

需要注意的是：主定理并不涵盖所有情况,比较的大小是多项式意义下的大小。例如，$f(n) = nlgn $ 和n进行比较，就无法归类到三种情况中的任何一种。在习题中我们可以知道，$n^{log_b a}lgn^k,k>0$ 和 $n^{log_b a} $比较对应的解为 $n^{log_b a}lg^{k+1}$,具体的证明我使用积分估计法。
 
##### 主定理的证明
定理的证明由以下两大步组成：
1. 对n是b的幂次的情况进行证明，即 $n = b^i,i ∈ N^*$。
2. 对n是正整数的情况进行证明。

第一大步可分为三小步:
1. 使用递归树法得到T(n)表达式 
$$ T(n) = n^{log_b a} + \sum_{i=0}^{i = log_b n - 1}a^j (\frac{n}{b^j}) $$
其中第一项由叶节点贡献，迭代 $log_b n$ 次后得到 $a^{log_b n} = n^{log_b a}$ 个叶节点，每个贡献常量时间，假计为1，则总和为 $n^{log_b a}$。

第二项由根节点贡献，计数求和即得。

2. 对于三种情况，计算第二项求和的结果。带入数据计算得出
$$
\sum_{i=0}^{i = log_b n - 1}a^j (\frac{n}{b^j}) = \begin{cases}
O(n^{log_b a}) & \text{if } case1 \\  
\Theta(n^{log_b a}lgn) & \text{if } case2 \\
\Theta(f(n)) & \text{if } case3
\end{cases}
$$
这里需要指出，前两种情况放缩/直接求和即可，第三种情况先证明求和式 = $\Omega(f(n))$，再利用正则条件证明求和式 = $O(f(n))$。 

3. 合并，分析得出结果。

接下来是第二大步，将结果推广到所有整数n。

只需对一种情况 $ T(n) = aT(\lceil n/b \rceil) + f(n) $ 完成证明即可，向下取整的情况类似。

T(n)的下界是容易确定的，直接放缩即可。关于上界，需要一些代数上的变形和推导，具体过程可以参考算法导论第60页内容，仍然是类似第一大步中的推导过程。

#### 一道习题
最后记录一下一道思考题。
假设有n个芯片，芯片要么是好的要么是坏的。通过两两配对的方式进行检测，好的芯片检测另一个芯片给出准确结果，坏的芯片检测配对的芯片，给出的结果可能正确也可能不正确。在好的芯片数量>n/2的情况下，请你发明一种算法，寻找一枚好的芯片。

原问题给出了解决问题的脚手架，一步步引导你解决最终的问题。在好芯片数量>n\2的情况下才可能存在寻找好芯片的算法-->使用递归方法，每次至少将规模降低一半-->解决问题。规模至少降低一半:算法选择两两配对，每对选一个；为保证子问题仍满足条件，不能随便选，必须满足一个约束条件才能进行选择-->找到约束条件，验证猜想,得到正确算法。


