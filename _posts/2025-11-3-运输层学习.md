---
layout: post
title: "应用层学习"
date: 2025-10-14
tags: [编程]
comments: true
author: Minrain
---
## 概述和运输层服务

运输层协议是写在端系统上的协议，负责把应用程序的报文转化为报文段，以实现运行在不同主机上的应用程序进程的**逻辑通信**（端与端系统之间看似直接通信，实际经过多个路由器和中间网络）。我们主要讲两种主要的运输层协议：TCP和UDP。

### 3.1.1 运输层和网络层的关系
考虑这样一个类比，A家庭有12个孩子，B家庭有12个孩子，这24个人相互通信。A家庭向B家庭发信件，首先其它11个孩子把信件都交给老大，老大再把他们12个人的信件交给邮政公司；邮政公司接着把所有信件发到B家庭。B家庭的老大收到12封邮件，他通过邮件的收件人，再把这12封邮件分发给B家庭的各个孩子。

网络层好像邮政公司，负责把所有信件从A的家庭运送到B的家庭；运输层就好比家庭里的老大，收到信后，按照收信人把信件分发给其他孩子(其它进程)。

注意，运输层只工作在端系统，把数据推到网络层边缘，不参与实际的运输工作。

### 3.1.2 因特网运输层概述
本书中报文段指的是运输层的分组，网络层分组用数据报标识。而在某些文献中，UDP的分组也被称为数据报。分组，可以理解成邮递公司运输的包裹。

网络层的IP服务模型是**尽力而为交付服务**，不做任何确保，被称为不可靠交付。UDP同样不可靠，但TCP提供可靠数据传输，且有拥塞控制机制。

### 3.2 多路复用与多路分解
多路复用，就是A家庭的老大收集好所有孩子信件，一起交给邮递员的过程；多路分解，就是B家庭的老大接收到所有信件，根据收信人一个个分发给B家庭孩子的过程。

在计算机中，收信人和发信人分别被称为目的端口号字段，源端口号字段。端口号是一个16比特的数，在0～65535之间。0～1023范围的端口号称为周知端口号，使用受到限制。

UDP被一个二元组标识，目的端口号和目的IP；TCP被一个四元组标识，目的端口号，目的IP，源端口号，源IP。举例来说，给定一个IP,8.8.8.8，和一个目的端口号2222，如果是UDP套接字，那就唯一的定位到了这个套接字；如果是TCP套接字，定位不一定是唯一的，比如源IP为1.1.1.1，但一个源端口号为3333，一个源端口号为4444，这就对应两个不同的TCP套接字。

这里注意的是，一个TCP包传到服务器，服务器先检查有没有对应的四元组；没有的话再看是不是SYN包，是的话就为之建立新套接字，否则丢弃或复位。

### 3.3.1 无连接运输:UDP
UDP是仅提供必要服务的最简化的运输层协议，它只管收齐邮件/发放邮件，以及偶尔检查一下错漏，其余的事情一概不管。尽管它数据传输不可靠，但它的优点也很明显：没有TCP建立连接的时延(也是DNS应用选择UDP的原因)、不会被拥塞控制机制限速、不需要维护连接状态和参数、分组首部开销小。因此，除了一些要求传输可靠性的应用，比如：电子邮件、Web,有很多诸如因特网电话、网络管理等应用选择UDP作为运输协议。

UDP报文由2个端口号，1个长度，一个检验和组成首部，每个标签给2个字节；报文里写主要内容。检验和功能如下：16个二位数，16个二位数，16个二位数(2个端口号，1个长度)相加，溢出则回卷(多出来的1加到后面)，加完后每个位取反放到检验和部分。现在我们有四个16位的二进制数了，接收之后把他们4个相加，如果没有问题，结果应该是16个1。值得注意的是，有时一些特殊的差错，可能能够逃避检测。也就是说，这种检测不一定能检测出所有错误。

### 3.4 可靠数据传输原理
RDT(Reliable Data Transfer)，UDT(Unreliable Data Transfer)，FSM(Finite State Machine,有限状态机)。

### 3.4.1 构造可靠数据传输协议
我们从rdt1.0出发，逐渐构造一个可靠数据传输协议。

rdt1.0:运输层以下传输数据(邮政公司运输包裹)不丢包，包里的数据没有比特错误(包裹都到，东西也没问题)。

rdt2.0:运输层以下传输数据，不丢包，但包里的数据可能有问题。(包裹都到，包里的东西可能有损坏)。

rdt3.0:考虑丢包，考虑数据有问题。(包裹可能运不到，包里的东西也可能坏)。

想象你跟一个人通电话，要说一段很长很长的文字。

对于rdt1.0，你说一句话，你确信对方都能准确无误地接收，所以你就按顺序一句一句把话讲完，对方一句一句记录下来，传给有需要的人，这就结束了。

对于rdt2.0，对方可能某句话没有听清，所以你每句话说完之后，对方会说"OK"，或者"Please repeat"，来表示听懂了或者没有听懂，你将根据对方是说OK还是repeat来判断要不要重说这一句话。你说完一句话，不能立刻说下一句，因为你要等待对方ACK(Acknowledgement,肯定确认，例子中是OK)或者NCK(Not acknowledgement,否定确认，例子中是“Please repeat”)。这种发送完一个分组就停下来等待的协议，叫做停等协议。

但是这就带来了一个新问题：对方说OK,或者repeat，你没有听清怎么办？Yes or No,你听见对方说了句or，你该怎么处理？由此引出了rdt2.1,当接收到含糊不清的报文时，发送方无论如何都将重述这句话。但这又引发一个新问题，如果对方上句话说的是OK，你又重说了一遍，对方怎么判断你说的是下一句，还是这一句的重复呢？TCP，以及大部分协议的解决方法是，通过给每句话编号解决问题。譬如，我说一句话，我告诉你，这是序号1；接到你的回话，如果含糊不清，我就再说一遍，这是序号1。此时对方如果已经接收过这句话，他会继续往回传OK，你可以说下一句话了；如果对方不知道，一看上一句话是序号0，这句是序号1，知道这是下一句话，于是记录上，继续往回传OK。这样，圆满解决了问题。注意，这里的序号只需要mod2，因为你说一句话，接收方只需要判断两种可能：这句话是重复或这句话是下一句话。因此，你说完一句话，假设这句话编号为1，那么下句话可以编号为0，下下句话又继续编号为1，如此往复。

通过编号，对方甚至可以不用说repeat,会说OK就OK了，只不过也要带上编号。比如，你说了一句话，编号1；那么对方接收到的上句话编号为0。对方接受到了，回复OK,1；对方没有接受到，回复OK,0。这样，发送方同样知道对方是否接收到这句话，因此可以采取相应的行为。这就是rdt2.2。

对于rdt3.0,比对rdt2.2的机制几乎没有怎么变，它只需要确保无人响应时能够继续将对话进行下去就好。比如你在打电话时，你说完一句话，却没有收到回应。沉默一段时间后，你选择再说一遍话确定对方是否在线。通信也是这样，如果发生丢包事件，无论是去的包还是回来的包，都可能会造成长时间无响应的情况。解决方案是设置一个计时器，超时则重新发送数据/复述内容。这样的话，无论如何将确保通信能够进行下去。

你可能会有这样的疑惑，这样的方案真的可行吗？会不会产生错配的情况？或者因为传输时间过长，导致超时，实际对方收到了消息，由此带来一系列逻辑问题呢？我们来仔细看一下这套规则。超时被视为丢包，无论是丢包还是超时，被视为一种情况。在只考虑丢包的情况下，这套理论自然是可行的。如果超时但未丢包，即我重新发出包裹，实际上你的回复在路上且即将被我收到；在我收到之后，我会发送下一个包裹，次序在重新发出的包裹之后。那么除非我的包裹能实现“跳跃”，后发出的包裹比先发出的包裹更快到达收件人处，那么绝不会产生错配情况：处于K的包裹匹配到K+2的位置。返回的ACK包裹也是同理，先收到的重复包裹的ACK将被优先收到，不会对匹配顺序产生任何影响。因此，这套定时器方法，足够实现一个可靠的数据传输协议。

但这套协议有一个很大的问题：停等协议等待时间过长。你每发送一个包裹，发送包裹的时间占总时间(从发出包裹到收到回信)的比例其实很小，但你每次不得不等待回信。如果遇到丢包、错漏等情况，时间消耗只会更长。在一次通信中，从发送方发送包裹到发送方收到有效回信，发送方闲置的时间实在太长了！他只能像一个无所事事等待包裹的工人，低头玩手机了！

为了让这位工人忙碌起来，我们引入**流水线**技术。具体来说，我们通过扩大序号范围，让通信双方缓存分组等方法，使工人连续地把多个货物填充到流水线上运送过去，而不需要等到回信，提高工作效率。为了针对流水线工作中可能出现的疏漏，我们引入两个机制：**回退N步**(Go-Back-N,GBN)和**选择重传**(Selective Repeat,SR)。


回退N步:GBN协议，或称为**滑动窗口协议**。通过base和滑动窗口N的选择，将所有要使用的序号分为四段：发送且已确认的序号[1,base-1]，发送但未确认的序号[base,k]，可以使用的序号[k+1,base+N-1]，和不能使用的序号[base+N,+ $ \infty $]。实际使用时，发送方如果有发射需求(应用层调用发送数据命令)，先检测滑动窗口N内有没有可以使用的序号。如果有，就用这个序号标记该数据并发射，如果没有，则需要应用程序等一等。发送方每次接收到的ACK必须按序，它对base对应的分组进行定时，若超时则重新发送所有[base,k]分组，否则滑动窗口向前滑动；接收方每次接收到的分组也必须按序，比如它已接收前n-1个数，那么除了序号为n的分组，其他接收到的东西会一概丢弃，并返回ACK(n-1)。

概括地说，回退N步是加强版的rdt3.0通信协议，它不是一次发送一个，而是一次最多发送N个；但它的作用机理与rdt3.0几乎相同，在出现故障的情况下，只需要把这N个看作一个单位，对应到base分组。

选择重传:SR协议。同样选择一个滑动窗口N，同样把序号分为四类：已确认；发送未确认；可用未发送；不可用。接收方此时也有滑动窗口，大小为N，同样四类：期待未收到；缓存未上传；可接受；不可用。发送方操作如下：从上方接收数据，序号可用，发送数据；否则让上层应用等一等；接收到ACK，就确认某些序号；当窗口内第一个分组被确认，窗口向前滑动到第一个未被确认的位置。窗口内每个未确认的序号进行定时，超时就重新发送。

接收方操作如下：判断收到的分组序号在窗口内；若是窗口内第一个分组的序号，向前滑动窗口直到未确认接收的位置，并上传分组；否则缓存该分组，暂时不上传。

### 3.5.1 面向连接的运输，TCP协议
TCP被称为是面向连接的，提供**全双工服务**，也就是说通信双方可以同时发送和接收数据，互不干扰。TCP也是点对点的，只涉及两台主机。

客户向服务器发送数据，首先通过一个套接字接口，把数据塞过去；此时数据全权由运输层协议控制——这里是TCP——并被引导到**发送缓存**中。TCP之后不时从缓存中取数据，以报文段的方式发送。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文长度(MSS,Maximum Segment Size)。MSS通过最大链路层帧长度(所谓的最大传输单元，MTU,Maximum Transmission Unit)设置。MSS的典型值为1460字节。

TCP报文进入网络层，运输到服务器端后被接收缓存接收。两端都有各自的接收缓存和发送缓存。

所以TCP连接，发送端和接收端，都只由三部分：一个套接字，一个读数据、发数据的缓存、变量组成。

### 3.5.2 TCP报文段结构
TCP同样有两个端口号，首部长度和检验和字段。不同的是，它还有序号和确认号。一个经常没有用上的选项字段，加起来，它的首部长度一般是20字节。

序号是发出报文段中数据字段第一个字节的序号。比如A->B发送2个1000字节的数据a1,a2，a1的序号就是0，a2的序号就是1000；即字节对应的序号。确认号是A期望从B收到的下一个字节流对应的序号。比如A从B这里收到了0-535的字节，它给B传输字节流，确认号就是536。TCP提供累积确认，只确认该流中至第一个丢失字节为止的字节。因此，如果A没有收到536-1000而是收到了1001-1200，它怎么处理这个数据取决于具体实现。实践中会缓存该失序数据，以提高效率。

TCP协议的回应存在“捎带”机制，A给B发消息，B如果正好也要给A发消息，他就会把“确认收到”放进要发给A的包裹里，“顺带”发给A；如果B这时候不想给A发消息，B就会发一条单独的收到。
### 3.5.3 TCP重传时间的确定
TCP依靠超时进行重传，但这个时间不好确定：太短，重传次数过多；太长，又影响效率。本小节我们讨论这个问题。

TCP通过采样确定重传时间，具体来说，它会自己测量SampleRTT，并通过公式
$$ EstimatedRTT = (1-\alpha) * EstimatedRTT + \alpha * SampleRTT$$
维护一个EstimatedRTT值，我们稍后会讲到，重传时间是以EstimatedRTT为参数的函数。

SampleRTT的测量遵从以下规则：

1. 一次只测一个。比如A发送a,b,c,d，它选择测a的SampleRTT，在测量没有结束时，就不会管b,c,d的ACK。而测完a后，它
会继续选择，可能选b，也可能选d之后的。无论如何，一次只测一个包的SampleRTT。

2. 不测重传的包。比如原本测a，发生了超时，导致A不得不重发a,b,c,d，那么a,b,c,d都不会被选中测SampleRTT。

我们还要考虑每次SampleRTT的波动率DevRTT，定义为
$$ DevRTT = (1-\beta)*DevRTT + \beta*|SampleRTT - EstimatedRTT|$$

最终，我们将超时间隔表示为：
$$ TimeoutInterval = EstimatedRTT + 4*DevRTT$$

其中，EstimatedRTT相当于RTT的平均值，再考虑到波动率DevRTT，我们可以很负责地说，这个时间是合理的。除了个别极端情况，超时的分组应该确实丢失了。

### 3.5.4 TCP的可靠数据传输及特性
1. 超时间隔加倍。TCP每次重传还未被确认的报文，都会将超时间隔加倍，这可以视作拥塞控制的一种方式。
2. 快速重传。当接收方期待收到a,但却连着收到了b,c,d(假设原本发送a,b,c,d)，那么每次收到一个元素，接收方就会回答一个ACK强调期望收到a。当发送方收到3个这样的冗余ACK，就会启动快速重传机制，立即重传3次强调的分组，这里是a。
3. 回退N步和选择重传的结合体。TCP采用累积确认，发送方只维护一个send_base和一个next_sequence，听起来很像回退N步；然而它的接收方却会缓存到达的失序数组。另外，如果发送方重传分组，它只会重传确认丢失的分组，而在回退N步中它会全部重传。因此，TCP既不是完全的选择重传协议，也不是完全的回退N步协议，它是两者的综合体。

### 3.5.5 流量控制
流量控制服务是为了使发送方发送数据的速度匹配接收方读取数据的速度，防止超缓存持续丢失；而拥塞控制服务是避免IP网络层的堵塞问题。尽管解决两者问题的方式接近，但实则是为了不同的目的。

TCP通过维护一个**接收窗口**来提供流量控制服务。A向B传文件，用RcvBuffer表示B的缓存空间大小，rwnd表示接收窗口的大小，LastByteRead表示B的应用程序最后一次读入的字节在字节流中的序号，LastByteRcv表示已放入主机B缓存中的数据流最后一个字节的编号。显然，需要满足：
$$ LastByteRcv - LastByteRead \leq RcvBuffer$$
和
$$ rwnd = RcvBuffer - [LastByteRev - LastByteRead]$$

定义主机A最后一次发送报文的序号LastByteSent和A最后一次收到报文的序号LastByteAcked。它们的差值即为A中发送但未确认的字节数量。因此，只需要维持
$$ LastByteSent - LastByteAcked \leq rwnd$$
就可以实现流量控制。最后，为了避免B空间为0后，B的应用程序后续清空缓存A不知道的情况，在获悉B缓存为0后，A会不断发送一个字节的报文进行试探，直到B回复有多余的缓存空间。

### 3.5.6 TCP连接管理
TCP的三次握手：
1. 发送方发送一个特殊报文到等待的端口，该报文的标志位SYN被标为1，无数据内容，生成随机序号。
2. 服务器端确认连接建立，分配缓存和变量，并回复一个特殊报文SYNACK。没有内容，SYN标为1，确认号为发送方序号+1，序号是服务器的初始序号。
3. 发送方分配TCP缓存和变量，发送一个SYN值为0的报文，此时可以携带数据。

之后，双方可以互相传输数据，SYN值为0。

关闭连接的确认类似。发送方发送特殊报文段，FIN值置为1；服务器接收，回复确认报文端，FIN值为1；发送方确认。双方释放所有缓存和变量。

### 3.6 拥塞控制原理
拥塞控制有两种主流的方式：端到端拥塞控制和网络辅助的拥塞控制。TCP靠的是端到端拥塞控制。

### 3.7 TCP拥塞控制
将拥塞窗口表示为cwnd,TCP拥塞控制机制通过控制cwnd的大小来决定发射速度。特别的，未确认的分组数量小于两个窗口中的任意一个。
    $$ LastByteSent - LastByteAcked \leq min{cwnd,rwnd}$$

TCP通过确认来增加cwnd的长度从而提高发送数据的速度,被称为**自计时**的。当发生丢包事件时，它减小这个窗口；当正常收到确认，它就增大窗口；因此，收到确认的速度越快，说明网络越通畅，它增加的发送速度就越多，直到出现丢包，它开始减速。

### 3.7.1 TCP拥塞控制算法
1. 慢启动：

连接开始时，cwnd的值被设置为一个MSS的较小值，从而初始发送速率大约为MSS/RTT。每收到一个确认报文，窗口长度就翻倍。比如开始是1MSS，收到一个确认变成2MSS；发送2个报文，收到2个确认变成4MSS...尽管启动阶段速度较慢，然而该速度以指数速度上升。

结束慢启动有三种方式：一、发生超时导致的丢包事件。cwnd将被设置为1，并且变量ssthresh(慢启动阈值)被设置为原本cwnd的值/2。（刚开始的cwnd是∞）二、慢启动过程中cwnd超过ssthresh。这时TCP进入拥塞避免模式，更谨慎地增加cwnd。三、检测到3个冗余ACK。TCP执行快速重传，进入快速恢复模式当中。
2. 拥塞避免

此时cwnd增长速度变慢，表现为一个RTT只增加一个MSS。具体实现为每接收到一个ACK，就将窗口长度增加MSS/cwnd(单位为字节)个MSS。比如窗口长度为10个MSS，发送10个报文后，每接收到一个ACK，cwnd长度就增加1/10MSS。

那么何时停止这种增长？与慢启动阶段类似，当发生超时时，ssthresh被设置为原本cwnd的一半，cwnd长度变为一，进入慢启动阶段；但发生三ACK冗余提示时，先将ssthresh设为原本cwnd/2，再更新cwnd = ssthresh+3，进入快速恢复阶段。

3. 快速恢复
发送端立即重发对应报文(3冗余对应)，直到接收端确认收到丢失报文，每收到一个失序的ACK，使cwnd长度+1;确认丢失报文被收到，cwnd收缩到ssthresh,进入拥塞避免状态。如果过程中发生了丢包，将ssthresh设为cwnd值一半后，cwnd=1，返回慢启动阶段。

总结：TCP拥塞控制常常被称为**加性增、乘性减**(Additibe_Increase,Multiplicative_Decrease,AIMD)控制模式。长得像锯齿。上述三阶段的控制算法被称为TCPReno协议，去掉快速恢复阶段，每次丢包都进入慢启动阶段的变种叫做TCP_Tahoe。

新型TCP拥塞控制变种：TCP_CUBIC。它的核心思想是快速接近丢包时的最大窗口W_max,从而提高传输速率。具体来说，丢包时记录此时的窗口长度$W_max$->计算一个未来时间K->以|t-K|^3的速度增加窗口大小，以快速接近丢包时的速度。这也是名字Cubic的来源。

### TCP吞吐量的宏观描述
简化模型，我们以公式
$$ 一条链接的平均吞吐量=\frac{0.75*W}{RTT}$$
计算吞吐量。

### 3.7.2 网络辅助明确拥塞通告和基于时延的拥塞控制
明确拥塞通告(Explicit Congestion Notification,ECN)通过路由发送比特告知拥堵情况来调节窗口大小；基于时延的拥塞控制先测量RTT_min，得到不拥塞情况下的最大速率，再通过计算现在的运输速率和最大速率的比值，来判断是否拥塞以及控制速度。

### 3.7.3 TCP和UDP的公平性
理想情况下，TCP的带宽是公平的，即一个应用和另一个平分带宽。然而实际中因为可以一个应用并联开多个TCP接口，带宽在应用间很难公平分配。另外，UDP也难以保证公平性，它只会不断地被发出，而不管网络层的压力。

### 3.7.4 QUIC
应用层协议，在UDP基础上，开发出控制流量功能的新式协议。它提供：面向连接和安全的服务、数据流的服务、可靠的、TCP友好的拥塞控制数传输。它有点像UDP和TCP的综合体。

