---
layout: post
title: "动态规划"
date: 2025-11-26
tags: [编程]
comments: true
author: Minrain
---
## 2.矩阵链乘问题：
15.2-3: 使用代入法证明
    $$ P(n) = \begin{cases}
    1, & n=1 \\
    \sum_{k=1}^{n-1} P(k)P(n-k), & n \ge 2
    \end{cases}     = \Omega(2^n)
    $$

证明: 使用代入法，设当k>p时，$P(k) >= c2^k$,那么由于P(1)P(n-1)中出现一次$P(n-1)>=c2^{n-1}$,P(n-1)P(1)中出

现一次P(n-1)，最后的结果大于等于$2P(n-1)>= 2^n$，证明完毕

15.2-4: 对输入链长度为 的矩阵链乘法问题，描述其子问题图：它包含多少个顶点？包含多少条边？这些边分别连接哪些顶点？

解: 顶点数:长度为1的n个，长度为2的n-1个......长度为n的1个，总数目1+2+3+4+..+n = n(n-1)/2个。  边数：长度为k的数组，有2k-2条边(k-1个可选的断开点，每个断开点对应两个问题)。总数$ \sum_{l=2}^n (n-l+1)*(2l-2) = \frac{n^3-n}{3}$。这些边连接对应子问题的顶点。

15.2-5： 令$R(i, j)$表示在一次调用 MATRIX-CHAIN-ORDER 过程中，计算其他表项时访问表项
m[i, j] 的次数。证明：$ \sum_{i=1}^n \sum_{j=1}^n R(i,j) = \frac{n^3 -n}{3}$

证明：每次调用某个表项对应连接它的一条边，所以该求和对应子问题中总边的数量，即$\frac{n^3 - n}{3}$

15.2-6: 证明：对n个元素的表达式进行完全括号化，恰好需要n-1对括号。

证明：归纳证明。n=1时成立，设当对k<=n-1均成立，考虑k=n时：第一步，选中两个相邻元素进行第一次运算；将加上括号后的两个元素看作一个整体，现在有n-1个元素；由归纳假设，进行完全括号化需要n-2对括号；加上第一次的一对括号，从而对k=n时，结论仍成立。

## 3.动态规划原理
关于什么样的问题能够用动态规划方法解决，主要有两点：最优子结构和子问题重叠。

1. 最优子结构。通常遵循以下模式：一、证明问题最优解的第一个组成部分是做出一个选择，这个选择会产生一个或多个子问题。     二、对于一个给定问题，你假定知道了该选择的最优解。      三、假定最优解之后，你要确定你会得到什么样的子问题，然后最好地刻画子问题空间。          四、通过复制粘贴技术，反证法证明原问题最优解由子问题最优解构造而成。

2. 子问题重叠。动态规划能解决的问题，子问题空间必须足够小。每次做出选择不产生新的子问题，只需要解决有限多个重复的子问题。

能用动态规划解决的问题，还有一点：两个子问题必须独立，互不干扰；解决一个子问题所消耗的资源，不影响另外子问题解决问题的方案。

15.3-1 对于矩阵链乘法问题，下面两种确定最优代价的方法哪种更高效？第一种方法是穷举所有可能的括号化方案，对每种方案计算乘法运算次数，第二种方法是运行
RECURSIVE-MATRIX-CHAIN 。证明你的结论。

Recursive_matrix_chain方法更高效。证明：穷举方案总数是卡特兰数，$\Omega(4^n)$。递归方案为$O(3^n)$，递归方案更加高效。

下面给出递归方案时间复杂度估算证明：$$T(n) = \sum_{k=1}^{n-1} (T(k) + T(n-k)) + O(n) = 2\sum_{k=1}^{n-1}T(k) +O(n)$$
考虑$T(n-1)=2\sum_{k=1}^{n-2} + O(n-1)$,得$T(n) - T(n-1) = 2T(n-1) + O(n)$

从而T(n) = O(3^n),证明完毕。