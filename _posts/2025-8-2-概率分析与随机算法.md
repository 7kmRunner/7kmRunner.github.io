---
layout: post
title: "概率分析与随机算法"
date: 2025-8-2
tags: [编程]
comments: true
author: Minrain
---
## 一、从雇佣问题说起
所谓雇佣问题，是指从随机排列的n个优先级不同的候选人序列中，在更新候选人次数较少时，选择最佳候选人的问题。

### 遍历雇佣方案
第一种策略是遍历策略。通过遍历整个序列，如果发现当前候选人比已雇佣的候选人优秀，则更换候选人。伪代码如下：
```
best = 0
for i = 1 to n
    if score[i] > best
    candidate = i
    best = score[i]
```
关于随机性，由于我们是主观假定候选人名单是服从随机排列的，实际情况可能并非如此。为了更加严格，确保序列确实是等概率随机的，就需要随机算法的帮助。随机算法的作用，就在于给定一个特定的输入序列后，对其进行随机化，确保每次实际运行时，操作的序列是随机的。

这部分内容放在第二小节，现在我们继续对雇佣问题进行概率分析。比如，我们希望计算采取这种方法，candidate更新次数的期望是多少。

如果采取分析 $ P(X = i)$ ，利用 $ E(X) = \sum_{i=1}^n iP(X = i) $ 的定义法，分析是复杂而困难的.实际上，我们可以采用指示函数的方法来解决问题。
$$  X = \sum_{i=1}^n I_i   $$
其中当第i个候选人被录用，$I_i = 1$,否则为0。

此时有
$$  E[X] = \sum_{i=1}^n E[I_i] = \sum_{i=1}^n P(第i个候选人分数大于前i-1个候选人) $$
而按照各个排列是等概率的假设，前i个下标中，每个下标取最大分数的概率是相等的，为 $\frac{1}{i}$。
于是得到最终结果:
$$ E[X] = \sum_{i=1}^n \frac{1}{i} = \ln n + O(1) $$
也即，按照这种策略，我们期望更新candidate $\ln n $ 次。

### 在线雇佣方案
另一种策略，我们通过选定一个参数k，记录前k个候选者中最高的分数;按顺序检验后i-k个候选者，选中第一个分数大于该最大值的候选者；如不存在，则选中第n个候选者。伪代码如下：
```
best = 0
for i = 1 to k
    if score[i] > best
    best = score[i]
for j = k+1 to n
    if score[j] > best
    return j
return n
```
如何选择参数k使得选中最优秀候选者的概率最大化？下面对这个问题进行分析。

固定k，以S表示 $P(成功选择最优秀候选者)$，$S_i$ 表示在第i个位置选择最优秀候选者。
那么，
$$ P(S) = \sum_{i=k+1}^{n} P(S_i)   $$

在第i个位置选择最优秀候选者，需要满足两个条件：一、第i个位置的候选者是最优秀的；二、前i-1个候选者中最大值在前k个候选者中产生。

记条件一为 $A_i$,条件二为 $B_i$，有
$$ P(S_i) = P(A_i B_i) = P(A_i)P(B_i | A_i) = P(A_i)P(B_i) $$
条件一，n个位置等可能地为最大值，得到 $P(A_i) = \frac{1}{n} $;条件二，i-1个位置等可能为最大值，得到 $P(B_i) = \frac{k}{i-1} $。

综上，有
$$ P(S) = \sum_{i=k+1}^{n} P(S_i) = \sum_{i=k+1}^{n} \frac{k}{n} \frac{1}{i-1} = \frac{k}{n} \sum_{i=k}^{n-1} \frac{1}{i} $$

使用积分对求和式进行估计，得到
$$ \frac{k}{n}(\ln n - \ln k)≤P(S)≤\frac{k}{n}(\ln (n-1) - \ln (k-1))
$$
再利用导数对下界表达式求导，求出其极值:当 $k=\frac{n}{e}$ 时，有最大下界 $\frac{1}{e}$。

## 二、关于随机算法
问题来到我们怎样使用一个随机算法，使得所有排列等概率出现。

### key值标识法
该方法对于每个i，随机产生一个标识优先级的key值，根据key值大小进行排列。

方法的优势在于，原理直观明白，劣势在于，可能遇到有两个值优先级相同的情况。为了改进，通常随机生成 $[1,n^3]$ 区间内的数字，降低优先级相同的概率；或者采用多key方法，第一个key值相同则比较第二个，以此类推。不过仍无法完全避免该问题。

方法伪代码如下：
```
for i = 1 to n:
    key[i] = RANDOM(1,$n^3$)
premute by key
```
现在给出该方法的理论证明，证明每种排列等概率出现，为 $\frac{1}{n!}$。

假设key值两两不同，任意给定一组排列，则要求第一个元素对应最大的优先级，第二个元素对应第二大的优先级...第i个元素对应第i大的优先级。第i个条件记为 $A_i$
，我们需要满足n个条件。即所求概率满足
$$ P(\prod_{i=1}^n A_i) = P(A_1)P(\prod_{i=2}^n A_i|A_1)$$
使用条件概率公式向下递推，可求得最后结果为 $\frac{1}{n!}$。这也就完成了证明。

### 随机交换法
这个方法的思路是，第i次迭代随机交换A[i]与A[i]后的某个值，包括A[i]。伪代码如下:
```
for i in range(1,A.lenth)
    swap(A[i],A[RANDOM(i,A.lenth)])
```
该算法明显更加优秀，因为：一、n次运行即结束(第一个算法运行时间不固定，由于要排序，最差运行时间一定大于nlgn)；二、不会出现某些无法处理的情况。

下面给出通过循环不变式给出算法正确性证明：

断言：
第i次循环后，对于任何i-排列，子数组A[1,i]包含该排列的概率为 $\frac{(n-i)!}{n!}

初始化:第1次迭代后，对于任何1-排列，子数组A[1]包含该排列的概率为 $\frac{1}{n} $，只需满足条件，在n个数中选中要求的一个，成立。

保持:第i次迭代后，假设断言成立，考虑第i+1次迭代后，给定一个i+1排列，子数组包含该排列的概率。这需要满足两个条件:1.A[1,i]是该排列前i个值；2.A[i+1]恰好为给定的数。分别记为A,B,总概率即为
$$ P(AB) = P(A)P(B|A) = \frac{(n-i)!}{(n)!} * \frac{1}{n-i} = \frac{(n-(i+1))!}{n!}  $$
成立。

终止：第n次迭代后，所求特定序列的概率即为 $\frac {1}{n!}$。

这也就完成了证明。

## 三、一些例子
在这个部分，我们分析一些常见的概率问题并给出解答。某些经典的但稍简单的课后习题不予列出，建议个人完成原书课后习题。
### 生日悖论
假设每个人的生日均匀散布在一年n=365日中，每个人的生日随机相互独立，问至少有k个人时，存在两人生日相同的概率大于50%？

设事件 $A_k$，存在两个人生日相同，事件 $B_k$，不存在两个人生日相同，也即生日两两不同。那么 $$P(A_k) = 1-P(B_k)$$

k个人生日两两不同，又可以转化为k-1个人生日两两不同，再添加一个人生日两两不同。

$$ P(B_k) = P(B_{k-1})P(B_k|B_{k-1})$$

由 $P(B_1) = 1$，$P(B_k|B_{k-1})= \frac{n-(k-1)}{n}$，递推即可得到
$$ P(B_k) = \frac{n!}{(n-k)!\ n^k}$$
$P(A_k) ≥ \frac{1}{2}$,也即 $P(B_k) ≤ \frac{1}{2}$。

采用放缩的方法给出大概估算：
$$ P(B_k) = 1*(1-\frac{1}{n})(1-\frac{2}{n})...(1-\frac{k-1}{n}) ≤ e^{-\sum_{i=1}^{k-1} \frac{i}{n}} = e^{-\frac{k(k-1)}{2n}}$$
令其≤$\frac{1}{2}$，解得k≥23。这也就是问题的解。

### 卡牌收集者
问题描述如下：有一套共n张的卡牌，每次买卡包等概率地获得其中一张牌。期望买多少次卡包后，能够收集齐这套牌？

假定我们已经拥有其中的k种牌，接下来买牌我们只希望买到没有的牌。思考发现，买到下一张没有的牌的次数分布满足几何分布。因此，假设X为收集齐这套牌所需的总次数，$A_i$为买到第i种没有的牌所需的次数，那么：
$$ X=\sum_{i=1}^n A_i,E[X] = \sum_{i=1}^n E[A_i] $$
为了买到第i种我们没有的牌(我们已经有了i-1种牌)，每次成功的概率为 $\frac{n-i+1}{n}$。由几何分布的期望为 $\frac{1}{p}$ (p为成功概率)，可计算出
$E[A_i] = \frac{n}{n-i+1}$。因此，所求期望为
$$ E[X] = \sum_{i=1}^n \frac{n}{n-i+1} = n \sum_{i=1}^n \frac{1}{i} = nlgn + O(n) $$

问题得到解决，想要一套完整的卡牌，大概需要买nlgn次卡包。

### 特征序列
问题描述：掷n次均匀硬币，最长的连续正面朝上的序列的长度期望是多少？

称该序列为特征序列，记其长度为$L,L_i$ 表示序列长度恰好为i的事件,先证明L=O(logn)。

记 $A_ik$ 表示事件从第i个位置开始，连续正面朝上的序列长度大于等于k,可得 $P(A_{ik}) = \frac{1}{2^k}$。

对于 $k=2\lceil lgn \rceil,L≥k$ 的概率为：
$$ P(\bigcup_{i=1}^{n-k+1} A_{ik}) \le  \sum_{i=1}^{n-k+1}P(A_{ik}) \le \sum_{i=1}^{n-k+1} \frac{1}{n^2} < \sum_{i=1}^n \frac{1}{n^2} = \frac{1}{n} $$
另一方面，这个概率也可以表示为
$$ \sum_{i=k}^{n} P(L_i) $$
计算期望：
$$ E[L] = \sum_{i=1}^n iP(L_i) = \sum_{i=1}^{k-1} iP(L_i) + \sum_{i=k}^n iP(L_i) < k\sum_{i=1}^{k-1}P(L_j) + n\sum_{i=k}^n P(L_j)< k + 1=O(\lg n) $$

接下来证明 $L = \Omega(\lg n)$,从而证明 $E[L] = \Theta(\lg n)$。

我们考虑将抛掷的硬币分组，每组长度为 $s = \lfloor \frac{\lg n}{2} \rfloor$。将序列分为 $\lfloor n/s \rfloor = l$ 组，通过计算没有一个组是特征序列的概率，给出特征序列长度大于等于s的概率。

一个组不是特征序列的概率为:
$$ P(A) = 1 - \frac{1}{2^s} \le 1 - \frac{1}{\sqrt n}$$
所有组不是特征序列的概率为:
$$ P(B) = (P(A))^l \le (P(A))^{n/s - 1} \le (1-\frac{1}{\sqrt n})^{n/s - 1} \le (1-\frac{1}{\sqrt n})^{2n/lgn - 1} \le e^{-(2n/lgn-1)/\sqrt n} = O(e^{- \lg n}) = O(1/n) $$
需要指出，$-(2n/lgn -1)/\sqrt n \le -\lg n$，对足够大的n成立。证明是平凡的，移项后可以得到一边是根号n级别，一边是lgn方级别。

最后放缩即可:
$$ E[L] = \sum_{i=1}^n iP(L_i) \ge \sum_{i=s}^n sP(L_i) = s \sum_{i=s}^n \ge s(1-O(\frac{1}{n})) = \Omega(\lg n)


